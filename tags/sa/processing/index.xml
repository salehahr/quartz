<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>-sa/processing on Zettelkasten</title><link>https://salehahr.github.io/zettelkasten/tags/sa/processing/</link><description>Recent content in -sa/processing on Zettelkasten</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><atom:link href="https://salehahr.github.io/zettelkasten/tags/sa/processing/index.xml" rel="self" type="application/rss+xml"/><item><title>(Phil's Lab) Sensor Fusion series</title><link>https://salehahr.github.io/zettelkasten/bibliography/phils-lab-sensor-fusion/</link><pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/bibliography/phils-lab-sensor-fusion/</guid><description>Source: https://www.youtube.com/watch?v=RZd6XDx5VXo
Sensor fusion Gyroscope Example: UAV attitude estimation Goal:
To estimate roll and pitch angles of aircraft These angles are needed for feedback in autonomous control of an unmanned UAV We have:
3-axis accelerometer [$\text{m/s}^2$] 3-axis gyroscope [$\text{rad/s}$] Note:
Here, angles are measured in body frame and not in fixed/inertial frame!
Measured quantities:
acceleration
$\mathbf{a}_B = \left[\begin{array}{ccc} a_x &amp;amp; a_y &amp;amp; a_z \end{array}\right]^\text{T}$ roll rates from gyrometer (body) $\neq$ derivative of Euler angles (fixed)</description></item><item><title>Gyroscope/Gyrometer</title><link>https://salehahr.github.io/zettelkasten/sensors/gyroscope/</link><pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/sensors/gyroscope/</guid><description>Source: Phil&amp;rsquo;s Lab Gyroscope model $$ \begin{aligned} \mathbf{\omega}B &amp;amp;= \mathbf{\omega}\text{true} + \mathbf{\beta}(t) + \mathbf{\eta}(t) \end{aligned} $$
We need to transform these body rates to Euler rates! $$ \begin{aligned} \left[ \begin{array}{c} \dot{\phi} \ \dot{\theta} \end{array} \right] &amp;amp;= \left[ \begin{array}{ccc} 1 &amp;amp; \sin\phi \tan\theta &amp;amp; \cos\phi\tan\theta\
0 &amp;amp; \cos\phi &amp;amp; -\sin\phi \end{array} \right] \left[ \begin{array}{c}p\q\r\end{array} \right] \end{aligned} $$
Problem: $\phi$ and $\theta$ need to be known!
&amp;ndash;&amp;gt; integrate? $$\hat{\phi} = \int_0^T \dot{\phi}(t) ~dt ~?</description></item><item><title>Sensor fusion</title><link>https://salehahr.github.io/zettelkasten/sensors/sensor-fusion/</link><pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/sensors/sensor-fusion/</guid><description>Source: Phil&amp;rsquo;s Lab Definition Combine multiple sensor readings to form an improved estimate of a desired variable.
Why sensor fusion? Overcome limitations of individual sensors (noise, uncertainty) Estimate quantities that are not directly measurable
e.g. gyroscope measures angular rates of change but can&amp;rsquo;t directly measure roll and pitch angle Fusion in IMU Accelerometer only: good estimate in non-accelerating conditions Gyroscope only: good estimate over short periods of time (due to integration of bias terms)</description></item><item><title>scipy.optimize</title><link>https://salehahr.github.io/zettelkasten/studienarbeit/scipy.optimize/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/studienarbeit/scipy.optimize/</guid><description>http://stackoverflow.com/questions/52438263/scipy-optimize-gets-trapped-in-local-minima-what-can-i-do
Local optims sensitive to initial value. Workarounds:
use your optimization in a loop with random starting points inside your boundaries
use an algorithm that can break free of local minima, I can recommend scipy&amp;rsquo;s basinhopping() It repeats your minimize procedure multiple times and get multiple local minimums. The minimal one is the global minimum.
use a global optimization algorithm and use it&amp;rsquo;s result as initial value for a local algorithm.</description></item><item><title>Symbolic container for Probe</title><link>https://salehahr.github.io/zettelkasten/studienarbeit/symbolic-container-for-probe/</link><pubDate>Sat, 17 Jul 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/studienarbeit/symbolic-container-for-probe/</guid><description/></item><item><title>KF kinematics</title><link>https://salehahr.github.io/zettelkasten/studienarbeit/kf-kinematics/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/studienarbeit/kf-kinematics/</guid><description>Overview of KF states (true, nominal, error) Nominal state kinematics Error state kinematics Old stuff:</description></item><item><title>Modes of operation of the scope</title><link>https://salehahr.github.io/zettelkasten/studienarbeit/modes-of-operation-of-the-scope/</link><pubDate>Wed, 30 Jun 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/studienarbeit/modes-of-operation-of-the-scope/</guid><description/></item></channel></rss>