<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>to-do on</title><link>https://salehahr.github.io/quartz/tags/to-do/</link><description>Recent content in to-do on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 20 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://salehahr.github.io/quartz/tags/to-do/index.xml" rel="self" type="application/rss+xml"/><item><title>Rigid cystoscope dimensions</title><link>https://salehahr.github.io/quartz/studienarbeit/rigid-cystoscope-dimensions/</link><pubDate>Fri, 20 Aug 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/rigid-cystoscope-dimensions/</guid><description> ca 20cm x 65 cm = 0.02m x 0.065 m
Source: http://en.wikipedia.org/wiki/Cystoscopy
The sizes of the sheath of the rigid cystoscope are 17 French gauge (5.7 mm diameter), 19 Fr gauge (6.3 mm diameter), and 22 Fr gauge (7.3 mm diameter).
Source: http://www.karlstorz.com/cps/rde/xbcr/karlstorz_assets/ASSETS/3405020.pdf Camera</description></item><item><title>Gibbs / Rodrigues parameter representation for rotations</title><link>https://salehahr.github.io/quartz/studienarbeit/gibbs-rodrigues-parameter-representation-for-rotations/</link><pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/gibbs-rodrigues-parameter-representation-for-rotations/</guid><description>Parent: Orientation parametrisations Backlinks: [50.5.1 Observation of the error state (filter correction)](50.5.1 observation of the error state (filter correction).md), 50.5.3-eskf-reset See also: Rotation error representation Source: Markley 2014 From unit quaternions : From Euler axis/angle : To unit quaternions :   Plane of the figure contains identity quaternion, origin The circle is a cross section of the quaternion sphere S^3 The upper horizontal axis is the 3D Gibbs vector hyperplane (tangent at the identity quaternion) [+] q and -q map to the same Gibbs vector, therefore there is a 1:1 mapping of rotations between quaternions and the Gibbs parameter [-] the Gibbs vector is infinite for 180 degree rotations (q.</description></item><item><title>Endoscopes</title><link>https://salehahr.github.io/quartz/permanent/30-endoscopes/</link><pubDate>Wed, 21 Jul 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/permanent/30-endoscopes/</guid><description>Backlinks: Leiner Endoscopy and bladder cancery surgery
Relate endoscopy to bladder cancery surgery &amp;hellip; Procedure:
Cystoscopy to inspect the bladder If tumour is found, do resection &amp;ndash;&amp;gt; cryosection Cancer detected &amp;ndash;&amp;gt; tumour removal Endoscopy Endoscopes (general) Types of endoscopes Endoscope system components Endoscope specification</description></item><item><title>Symbolic container for Probe</title><link>https://salehahr.github.io/quartz/studienarbeit/symbolic-container-for-probe/</link><pubDate>Sat, 17 Jul 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/symbolic-container-for-probe/</guid><description/></item><item><title>KF kinematics</title><link>https://salehahr.github.io/quartz/studienarbeit/kf-kinematics/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/kf-kinematics/</guid><description>Overview of KF states (true, nominal, error) Nominal state kinematics Error state kinematics Old stuff:</description></item><item><title>Program outline</title><link>https://salehahr.github.io/quartz/studienarbeit/program-outline/</link><pubDate>Wed, 07 Jul 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/program-outline/</guid><description>Current assumptions (to take care of later!)
Probe is rigid — DOFs are either 0 or constant — switch to rotating scope later No gravity No bias/offset, no noise in IMU Note: Stuff marked with checkboxes are either to-dos or things I&amp;rsquo;m not sure that I implemented correctly
http://github.com/feudalism/dvi-ekf/tree/eskf; projects generate_data.py Data generation (is called from main.py)
Main objects
Generate camera data (from DefSLAM mono trajectory) Make RigidSimpleProbe (for now, all DOFs are 0 or constant) Make IMU object, generate first (om, acc) values from interpolated camera data ( - should generate it from stereo data instead) Variables</description></item><item><title>Program outline</title><link>https://salehahr.github.io/quartz/studienarbeit/program-outline/</link><pubDate>Wed, 07 Jul 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/program-outline/</guid><description>Current assumptions (to take care of later!)
Probe is rigid — DOFs are either 0 or constant — switch to rotating scope later No gravity No bias/offset, no noise in IMU Note: Stuff marked with checkboxes are either to-dos or things I&amp;rsquo;m not sure that I implemented correctly
http://github.com/feudalism/dvi-ekf/tree/eskf; projects generate_data.py Data generation (is called from main.py)
Main objects
Generate camera data (from DefSLAM mono trajectory) Make RigidSimpleProbe (for now, all DOFs are 0 or constant) Make IMU object, generate first (om, acc) values from interpolated camera data ( - should generate it from stereo data instead) Variables</description></item><item><title>Modes of operation of the scope</title><link>https://salehahr.github.io/quartz/studienarbeit/modes-of-operation-of-the-scope/</link><pubDate>Wed, 30 Jun 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/modes-of-operation-of-the-scope/</guid><description/></item><item><title>Camera views as seen by SLAM at distal end of probe/scope</title><link>https://salehahr.github.io/quartz/studienarbeit/camera-views-as-seen-by-slam-at-distal-end-of-probe-scope/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/camera-views-as-seen-by-slam-at-distal-end-of-probe-scope/</guid><description/></item><item><title>Update 2021-06-11</title><link>https://salehahr.github.io/quartz/studienarbeit/update-2021-06-11/</link><pubDate>Fri, 11 Jun 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/update-2021-06-11/</guid><description>General model for probe (from Forward kinematics IMU to camera )
Using the standard DH convention  Note: I have since changed the axis configuration at the camera part—above diagram is no longer up to date; to be updated!
This has the IMU (B) as the base and the camera (C) as the end effector Using robotics-toolbox-python: http://github.com/petercorke/robotics-toolbox-python Simplified model (from Forward kinematics IMU to camera ) Currently using a simplified model with all degrees of freedom set to 0 or constant Modification to (above) existing robot model Probably need to modify the rotational joints around the pivot s.</description></item><item><title>Modified vs original DH</title><link>https://salehahr.github.io/quartz/studienarbeit/modified-vs-original-dh/</link><pubDate>Tue, 25 May 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/modified-vs-original-dh/</guid><description>Wikipedia
Modified DH (proximal) Original DH (distal?) a: offset in x (from old origin)alpha: twist of z around old x axisd: offset in z (to next origin)theta: rotation around current z d: offset in z (from prev origin)theta: rotation around prev zr / a: offset in x from prev originalp: twist of z around current x</description></item><item><title>Spherical wrist</title><link>https://salehahr.github.io/quartz/studienarbeit/spherical-wrist/</link><pubDate>Tue, 25 May 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/spherical-wrist/</guid><description>http://www1.cs.columbia.edu/~allen/F15/NOTES/forwardspong.pdf
S. also http://www.youtube.com/watch?v=S6TFakW5YcI</description></item><item><title>Modified Denavit-Hartenberg convention</title><link>https://salehahr.github.io/quartz/studienarbeit/modified-denavit-hartenberg-convention/</link><pubDate>Mon, 24 May 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/modified-denavit-hartenberg-convention/</guid><description>Source: Craig - Introduction to Robotics Backlinks: Kinematics primer Note: s. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1083.6428&amp;amp;rep=rep1&amp;amp;type=pdf for comparison (Lipkin)
Link-frame attachment
Identify joint axes
For joint axes i and i+1, identify the  common perpendicular + where it meets axis i, or point of intersection and let this be the link-frame origin Let Z_i point along the i-th joint axis
Let X_i
point along common perpendicular, or be normal to the plane containing the two axes Assign Y_i (right hand coordinate system)</description></item><item><title>50.7 ESKF update / Fusing IMU with complementary sensory data</title><link>https://salehahr.github.io/quartz/studienarbeit/50.7-eskf-update-fusing-imu-with-complementary-sensory-data/</link><pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/50.7-eskf-update-fusing-imu-with-complementary-sensory-data/</guid><description>Parent: [IMU index](imu index.md), 50.3 error-state-kalman-filter Source: Solà 2017 Quaternion kinematics for ESKF In the ESKF, the arrival of non-IMU sensor data triggers a correction stage. This correction makes the IMU biases observable , allows correct estimation of the biases The correction stage is three-fold:
observe the error state by way of filter correction &amp;lsquo;add&amp;rsquo; the observed errors to the nominal state to get the supposed &amp;lsquo;true&amp;rsquo; state according to the composition rules in variables in ESKF using IMUs reset the error state Source: Markley 2014 What if several measurements come in without IMU / propagation in between (i.</description></item><item><title>50.5 Error-State Kalman Filter</title><link>https://salehahr.github.io/quartz/studienarbeit/50.5-error-state-kalman-filter/</link><pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/50.5-error-state-kalman-filter/</guid><description>Source: Markley An EKF propagates the expectation and covariance of the state The MEKF propagates the expectation and the covariance of the error state Source: Whampsey MEKF Previously: orientation is represented by one state Now: orientation is split up into  a large signal q_nom (nominal orientation) and a small signal (perturbation angle alpha) &amp;ndash; parametrises an error quaternion  This reformulates the error in terms of the group operation and so maintains the rotation invariance (rotation preserves the origin, length, angle between two vectors, orientation, etc.</description></item><item><title>note KF with missing measurements</title><link>https://salehahr.github.io/quartz/studienarbeit/note-kf-with-missing-measurements/</link><pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/note-kf-with-missing-measurements/</guid><description>Sources http://math.stackexchange.com/questions/982982/kalman-filter-with-missing-measurement-inputs http://opencv-users.1802565.n2.nabble.com/Kalman-filters-and-missing-measurements-td2886593.html
For a missing measurement:
use the last state estimate as a measurement set the covariance matrix of the measurement to essentially infinity. This would cause a Kalman filter to essentially ignore the new measurement since the ratio of the variance of the prediction to the measurement is zero. The result will be a new prediction that maintains velocity/acceleration but whose variance will grow according to the process noise.</description></item><item><title>note KF with different sampling rate</title><link>https://salehahr.github.io/quartz/studienarbeit/note-kf-with-different-sampling-rate/</link><pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/note-kf-with-different-sampling-rate/</guid><description>Source: http://stackoverflow.com/questions/59566384/kalman-filter-with-different-sampling-rate
Approach 1: KF with variable dt Approach 2: KF with static dt
&amp;lsquo;Sub&amp;rsquo; updates? e.g.
predict() update() with sensor A skip update() for sensor B since no measurement arrived update() with sensor c repeat Generally discouraged:
If not predicting before each update, there is the risk of the filter lagging behind real world dynamics. The update step at t=k compares a measurement zk to the projected (predicted) state xk.</description></item><item><title>On quaternions and rotation matrices</title><link>https://salehahr.github.io/quartz/studienarbeit/on-quaternions-and-rotation-matrices/</link><pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/on-quaternions-and-rotation-matrices/</guid><description>http://stackoverflow.com/questions/8919086/why-are-quaternions-used-for-rotations
It&amp;rsquo;s worth bearing in mind that all the properties related to rotation are not truly properties of Quaternions: they&amp;rsquo;re properties of Euler-Rodrigues Parameterisations, which is the actual 4-element structure used to describe a 3D rotation. Their relationship to Quaternions is purely due to a paper by Cayley, &amp;ldquo;On certain results related to Quaternions&amp;rdquo;, where the author observes the correlation between Quaternion multiplication and combination of Euler-Rodrigues parameterisations. This enabled aspects of Quaternion theory to be applied to the representation of rotations and especially to interpolating between them.</description></item><item><title>Fact checks</title><link>https://salehahr.github.io/quartz/studienarbeit/fact-checks/</link><pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/fact-checks/</guid><description>Parent: Thesis Duration of cryosection GRK stuff SLAM rigidity assumption camera-imu-complementarity</description></item><item><title>Pizarro 2016 Schwarps</title><link>https://salehahr.github.io/quartz/studienarbeit/pizarro-2016-schwarps/</link><pubDate>Sun, 20 Dec 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/pizarro-2016-schwarps/</guid><description>Author: Daniel Pizarro et al.
Abstract
Warp between two images of a deforming surface: a transformation that depict the geometric deformation between the two &amp;lsquo;maps points between images of a deforming surface&amp;rsquo; Current approach to enforce a warp&amp;rsquo;s smoothness: penalise its second order partial derivatives However this favours locally affine warps Does not capture the local projective component of the image deformation Propose: novel penalty to smooth the warp while capturing the deformation&amp;rsquo;s local projective structure Proposed penalty is based on equivalents to the Schwarzian derivatives Schwarzian derivatives: projective differential invariants exactly preserved by homographies Methodology to derive a set of PDEs with only homographies as the solutions Validation: Schwarps outperform existing warps in modeling and extrapolation power: perform better in deformable reconstruction methods Introduction/Related work</description></item><item><title>Schönheitsfehler</title><link>https://salehahr.github.io/quartz/studienarbeit/schoenheitsfehler/</link><pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/schoenheitsfehler/</guid><description>Parent: Thesis recreate diagrams in Inkscape / tikz binding correction and margins (esp on cover page) overfulls consistent colour scheme for diagrams bibliography style: preamble/bibstyle.tex nach ISO &amp;hellip; citeauthor without bibstyle page headers</description></item><item><title>Tex stuff</title><link>https://salehahr.github.io/quartz/studienarbeit/tex-stuff/</link><pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/tex-stuff/</guid><description>Parent: Thesis tikzexternalize
vimtex custom compile; include makeglossary
vim UltiSnips doesn&amp;rsquo;t work in math contexts! (Solved: &amp;lt;http://github.com/SirVer/ultisnips/issues/1193
issuecomment-620455011&amp;gt;)
get symbols to work with glossaries or glossaries-extra
set up spellcheck
automated list of symbols</description></item><item><title>Feature matching</title><link>https://salehahr.github.io/quartz/studienarbeit/feature-matching/</link><pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/feature-matching/</guid><description>Source: http://medium.com/data-breach/introduction-to-feature-detection-and-matching-65e27179885d Backlinks: Bag of words , sparse/feature-based-vslam For matching between images, i.e. to establish a relationship (&amp;lsquo;correspondence&amp;rsquo;) between two images of the same scene or object.
Basic algorithm
Find/detect a set of identifying (&amp;lsquo;distinctive&amp;rsquo;) keypoints from all images to be matched Define a search region around each keypoint Extract and normalise the region content Compute a local descriptor from the normalised region Match local descriptors between the images Performance of matching methods depend on</description></item><item><title>IMU preintegration on manifold</title><link>https://salehahr.github.io/quartz/studienarbeit/imu-preintegration-on-manifold/</link><pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/imu-preintegration-on-manifold/</guid><description>Parent: IMU index Source: Forster 2017 IMU Preintegration Backlinks: IMU model Preintegration on manifold
Summarising all measurements between the keyframes i and j into a single measurement This preintegrated IMU measurement constrains the motion between two consecutive keyframes Assume IMU is synchronised with the camera The above equations already provide the summarised IMU measurements, however, the integration has to be repeated whenever the linearisation point at t=t_i changes i.</description></item><item><title>Non-Rigid Guided Matching (b/w KFs) in DefSLAM</title><link>https://salehahr.github.io/quartz/studienarbeit/non-rigid-guided-matching-b-w-kfs-in-defslam/</link><pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/non-rigid-guided-matching-b-w-kfs-in-defslam/</guid><description>Source: Lamarca 2019 DefSLAM Backlinks: NRSfM in DefSLAM Matching between keyframes (used in deformation mapping in DefSLAM)
Use an estimated warp as a reference
To increase number of matches in the covisible keyframes Process
Matches are given by deformation tracking Estimate an initial warp between k and k* (covisible keyframes) how? Using this initial warp, estimate where a point would be seen in k* Define a search region around thesse estimated positions.</description></item><item><title>Surface alignment in DefSLAM</title><link>https://salehahr.github.io/quartz/studienarbeit/surface-alignment-in-defslam/</link><pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/surface-alignment-in-defslam/</guid><description>Parent: Mapping step-by-step in DefSLAM Source: Lamarca 2019 DefSLAM Goal:
to scale the up-to-scale surface (output of NRSfM) to the proper dimensions get an idea of the proper dimensions from the already estimated map i.e. resulting surface must match the scale of the template T_(k-1) T_(k-1): deformed map generated by the tracker at the instance of KF=k insertion, with shape-at-rest of S_(k-1) generated from KF:(k-1) result: scale-corrected shape-at-rest Sk Method:</description></item><item><title>Data association in DefSLAM</title><link>https://salehahr.github.io/quartz/studienarbeit/data-association-in-defslam/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/data-association-in-defslam/</guid><description>Source: Lamarca 2019 DefSLAM See also: Data association Goal: match keypoints in current frame (newly extracted) with map points (already in map/system) Use the active matching strategy proposed in [Agudo 2015]: “Simultaneous pose and non-rigid shape with particle dynamics,” Steps  ORB points (keypoints) are detected in current frame
Camera pose Tcw is predicted
using camera motion model camera motion model: function of past camera poses Predict where map points (existing in map) would be imaged, based on last estimated template i.</description></item><item><title>Mapping step-by-step in DefSLAM</title><link>https://salehahr.github.io/quartz/studienarbeit/mapping-step-by-step-in-defslam/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/mapping-step-by-step-in-defslam/</guid><description>Source: Lamarca 2019 DefSLAM Parent: DefSLAM framework Steps
Recover warps between k and k* (s. [Non-Rigid Guided Matching (b/w KFs) in DefSLAM](non-rigid guided-matching-(b_w-kfs)-in-defslam.md)) with k: anchor keyframes, i.e. KFs where one of the observed map points was initialised with k*: set of best covisible keyframes warps: transformation between the images Ik to Ik* In DefSLAM, Schwarps (a family of warps using 2D Schwarzian equation regularisers) is used Schwarps has something to do with the infinitesimal planarity assumption of NRSfM [ NRSfM ] Process k* to get estimate of an up-to-scale surface  Input of NRSfM: warps [ Surface alignment ] Up-to-scale surface (\hat{S}_k) is aligned with the whole map in order to obtained the scaled surface Sk w.</description></item><item><title>Mapping step-by-step in DefSLAM</title><link>https://salehahr.github.io/quartz/studienarbeit/mapping-step-by-step-in-defslam/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/mapping-step-by-step-in-defslam/</guid><description>Source: Lamarca 2019 DefSLAM Parent: DefSLAM framework Steps
Recover warps between k and k* (s. [Non-Rigid Guided Matching (b/w KFs) in DefSLAM](non-rigid guided-matching-(b_w-kfs)-in-defslam.md)) with k: anchor keyframes, i.e. KFs where one of the observed map points was initialised with k*: set of best covisible keyframes warps: transformation between the images Ik to Ik* In DefSLAM, Schwarps (a family of warps using 2D Schwarzian equation regularisers) is used Schwarps has something to do with the infinitesimal planarity assumption of NRSfM [ NRSfM ] Process k* to get estimate of an up-to-scale surface  Input of NRSfM: warps [ Surface alignment ] Up-to-scale surface (\hat{S}_k) is aligned with the whole map in order to obtained the scaled surface Sk w.</description></item><item><title>Non-rigid monocular techniques in the literature</title><link>https://salehahr.github.io/quartz/studienarbeit/non-rigid-monocular-techniques-in-the-literature/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/non-rigid-monocular-techniques-in-the-literature/</guid><description>Source: Lamarca 2019 DefSLAM SfT methods
require: 1 monocular image 1 textured shape at rest (template) &amp;ldquo;geometry&amp;rdquo; as the deformation model different definitions of the deformation model analytic, e.g. isometric deformation-based: assumes preserved geodesic distance between surface points isometry for SfT has proven to be well-posed &amp;ndash;&amp;gt; led to stable, real-time solutions energy-based; jointly minimises {energy shape w.r.t. template [shape at rest] + reprojection error for image correspondences} classification according to [ http://www.</description></item><item><title>Non-rigid monocular techniques in the literature</title><link>https://salehahr.github.io/quartz/studienarbeit/non-rigid-monocular-techniques-in-the-literature/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/non-rigid-monocular-techniques-in-the-literature/</guid><description>Source: Lamarca 2019 DefSLAM SfT methods
require: 1 monocular image 1 textured shape at rest (template) &amp;ldquo;geometry&amp;rdquo; as the deformation model different definitions of the deformation model analytic, e.g. isometric deformation-based: assumes preserved geodesic distance between surface points isometry for SfT has proven to be well-posed &amp;ndash;&amp;gt; led to stable, real-time solutions energy-based; jointly minimises {energy shape w.r.t. template [shape at rest] + reprojection error for image correspondences} classification according to [ http://www.</description></item><item><title>NRSfM in DefSLAM</title><link>https://salehahr.github.io/quartz/studienarbeit/nrsfm-in-defslam/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/nrsfm-in-defslam/</guid><description>Parent: Mapping step-by-step in DefSLAM Source: Lamarca 2019 DefSLAM Assumptions
Isometric deformation Infinitesimal planarity [DEF]: any surface can be approximated as a plane at infinitesimal level, all the while maintaining its curvature at a global level The method used here is a local method &amp;ndash;&amp;gt; implies that it handles missing data and occlusions inherently
surface deformation is modelled locally for each point, under the above assumptions Embedding, phi_k of the scene surface</description></item><item><title>NRSfM in DefSLAM</title><link>https://salehahr.github.io/quartz/studienarbeit/nrsfm-in-defslam/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/nrsfm-in-defslam/</guid><description>Parent: Mapping step-by-step in DefSLAM Source: Lamarca 2019 DefSLAM Assumptions
Isometric deformation Infinitesimal planarity [DEF]: any surface can be approximated as a plane at infinitesimal level, all the while maintaining its curvature at a global level The method used here is a local method &amp;ndash;&amp;gt; implies that it handles missing data and occlusions inherently
surface deformation is modelled locally for each point, under the above assumptions Embedding, phi_k of the scene surface</description></item><item><title>Tracking optimisation in DefSLAM</title><link>https://salehahr.github.io/quartz/studienarbeit/tracking-optimisation-in-defslam/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/tracking-optimisation-in-defslam/</guid><description>Source: Lamarca 2019 DefSLAM Backlinks: Template substitution in DefSLAM Optimisation function
Minimises reprojection error (in the image) deformation energy (of the template) boundary nodes of the local zone are fixed (i.e. not set as arguments to the optimisation function) this makes the absolute camera pose observable how? in order to constrain the gauge freedoms Initial guess: values from previous optimisation (i.e. previous frame: t-1) Reprojection error robust against outliers due to Huber robust kernel</description></item><item><title>Forster 2017 IMU Preintegration</title><link>https://salehahr.github.io/quartz/studienarbeit/forster-2017-imu-preintegration/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/forster-2017-imu-preintegration/</guid><description>Authors: Forster et al
Abstract:
First contribution: preintegration theory (building up on Lupton&amp;rsquo;s work) what&amp;rsquo;s different from Lupton&amp;rsquo;s: addresses manifold structure of the rotation group, analytic derivation of all Jacobians Lupton&amp;rsquo;s work uses Euler angles Using Euler angles and techniques of Euclidian spaces for state propagation/covariance estimation is not properly invariant under rigid transformations uncertainty propagation, a-posteriori bias correction same as Lupton: integration performed in local frame, eliminating need for reintegrating when linearisation point changes Second contribution: integration of the preintegrated IMU model into a visual-inertial pipeline The system presented uses incremental smoothing for fast computation of the optimal MAP estimate Uses structureless model (3D landmarks are not part of the variables to be estimated) for visual measurements &amp;ndash;&amp;gt; allows eliminating large numbers of variables Motivation:</description></item><item><title>Dynamic Bayesian Network formulation of SLAM</title><link>https://salehahr.github.io/quartz/studienarbeit/dynamic-bayesian-network-formulation-of-slam/</link><pubDate>Sat, 24 Oct 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/dynamic-bayesian-network-formulation-of-slam/</guid><description>Source: Grisetti 2011 - Tutorial graph-based SLAM Dynamic Bayesian Network
Solution of full SLAM problem: Transition model: Observation model:  The observation model is usually multimodal: a single observation may result in multiple edges (in the spatial graph) Therefore, the Gaussian assumption does not hold</description></item><item><title>(Mur-Artal 2017) VI-ORB</title><link>https://salehahr.github.io/quartz/studienarbeit/mur-artal-2017-vi-orb/</link><pubDate>Tue, 20 Oct 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/mur-artal-2017-vi-orb/</guid><description>Backlinks: Chen 2018 Review of VI SLAM , [keyframe-based tightly-coupled multisensor slam](keyframe-based tightly-coupled multisensor slam.md), todo , works of-possible-interest URL: http://ieeexplore.ieee.org/abstract/document/7817784, Authors: Mur-Artal, Tardós Code: http://paperswithcode.com/paper/visual-inertial-monocular-slam-with-map-reuse Results (video): http://www.youtube.com/watch?v=JXRCSovuxbA
Abstract
current VI odometry approaches: drift accumulates due to lack of loop closure therefore there is a need for tightly-coupled VI-SLAM with loop closure and map reuse here: focus on monocular case, but applicable to other camera configurations builds on ORB-SLAM (from same author) IMU initialisation method (initialises: scale, gravity direction, velocities, gyroscope bias, accelerometer bias) depends on visual monocular initialisation (coupled initialisation) Other works: recent tightly-coupled VIO (both filtering- and optimisation-based) lack loop closure, so drift accumulates</description></item><item><title>Tracking in VIORB</title><link>https://salehahr.github.io/quartz/studienarbeit/tracking-in-viorb/</link><pubDate>Tue, 20 Oct 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/tracking-in-viorb/</guid><description>Source: Mur-Artal 2017 VI-ORB Tracking in VIORB
Visual-inertial tracking at frame rate, instead of using an ad-hoc motion model as in the original ORB-SLAM Tracked states: [sensor pose (R, p), velocities v, biases b] Once the camera pose is predicted, map points are projected, then matches with existing features on the frame Then optimise the current frame j, depending on whether the map has just been updated the map is unchanged Here, the optimisation function for tracking (when map unchanged) is:</description></item><item><title>Thesis</title><link>https://salehahr.github.io/quartz/studienarbeit/thesis/</link><pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/thesis/</guid><description>Parent: Scope of Studienarbeit See also: Schönheitsfehler , Tex stuff , Spelling , Notes on current thesis version , Fact checks **TO BE RESTRUCTURED** s. Thesis restructure Introduction
Bereits am Anfang (S.1) auf die Navigation eingehen GRK 2543 more on the navigation subtheme (loc. of other tools within camera view of the main probe &amp;ndash; relate to generalisability of optim.-based methods later on) Problem statement Literature review/Stand der Technik/Other works Visual tracking review: types of algos available VI-Review filt-based, opt-based  DefSLAM use of ORB features in def.</description></item><item><title>Showing correlation using error ellipses</title><link>https://salehahr.github.io/quartz/studienarbeit/showing-correlation-using-error-ellipses/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/showing-correlation-using-error-ellipses/</guid><description>Parent: Error ellipse/Confidence ellipse Source: rlabbe Kalman/Bayesian filters in Python A slanted ellipse implies correlation
The &amp;lsquo;thinner&amp;rsquo; side isn&amp;rsquo;t necessarily more accurate, it just means that the spread of data is reduced along this dimension (when viewing sensor data, for example) Example First epoch Yellow: prior (very uncertain about position) Green: evidence (more accurate in one of the dimensions than the other; more certainty compared to prior) Blue: posterior via multiplication Posterior retains the shape of the evidence (which has more certainty than the prior)</description></item><item><title>50.2.10.1 Discrete Bayesian Filter Predict Step</title><link>https://salehahr.github.io/quartz/studienarbeit/50.2.10.1-discrete-bayesian-filter-predict-step/</link><pubDate>Mon, 31 Aug 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/50.2.10.1-discrete-bayesian-filter-predict-step/</guid><description>Parent: Discrete Bayesian filter Source: rlabbe Kalman/Bayesian filters in Python The predict step uses the total probability theorem.
Computes total probability of multiple possible events Uses the system model (propagates the states from prev. time step [posterior] to the next one); prediction Accounts for the uncertainty (kernel) in the prediction: produces a prior Generalise the uncertainty using a kernel (distributes the uncertainty over a range around the prediction) Integrate the kernel into the calculations by using convolution * Convolving the &amp;ldquo;current probabilistic estimate&amp;rdquo; with the &amp;ldquo;probabilistic estimate of how much we think the position has changed&amp;rdquo; (from system model) The prior is a &amp;lsquo;degraded&amp;rsquo; version of the belief i.</description></item><item><title>Expected value</title><link>https://salehahr.github.io/quartz/studienarbeit/expected-value/</link><pubDate>Thu, 27 Aug 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/expected-value/</guid><description>Source: rlabbe Kalman/Bayesian filters in Python Example: if we take a thousand sensor readings, the readings won&amp;rsquo;t always be the same (due to the inherent noise).
The expected value &amp;lsquo;averages&amp;rsquo; all of the readings into a single value. This can be a mean (probabilities of all values assumed equal) Or if incorporating individual and different probabilities, the expectation isn&amp;rsquo;t the mean of the range of values Proven: the average of a large number of measurements will be very close to the actual weight</description></item><item><title>Cadena 2016 Past, Present, and Future of SLAM</title><link>https://salehahr.github.io/quartz/studienarbeit/cadena-2016/</link><pubDate>Tue, 25 Aug 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/cadena-2016/</guid><description>Authors Cadena et al
Abstract
cited by 1.2k people &amp;ldquo;This paper simultaneously serves as a position paper and tutorial to those who are users of SLAM&amp;rdquo; Recommended other works s. Works of possible interest Contents/Chapters Takeaway</description></item><item><title>Chen 2018 SLAM-based dense surface reconstruction in MIS with AR</title><link>https://salehahr.github.io/quartz/studienarbeit/chen-2018-mis-slam/</link><pubDate>Mon, 24 Aug 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/chen-2018-mis-slam/</guid><description>Authors Chen et al
Abstract
Intra-operative dense surface reconstruction framework to provide geometry information from only monocular videos The proposed framework works well with rapid camera movements, however is not suitable for large deformations Only tweaks ORBSLAM to adjust between point density and computational performance Contents/Chapters Problems in medical AR:
tissue surface illumination tissue deformation rapid movements of the medical tool e.g. endoscope (s. also kidnapped robot problem for relocalisation, tracking mus therefore be robust) field of view often very small &amp;ldquo;A typical human uses 14 visual cues to perceive depth, only 3/14 are binocular vision related.</description></item><item><title>Information Filter</title><link>https://salehahr.github.io/quartz/studienarbeit/information-filter/</link><pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/information-filter/</guid><description>Parent: General Kalman Filter Source: Scaradozzi 2018 SLAM application in surgery also same assumptions as the EKF main difference: how the Gaussian belief is represented est. cov. — replaced by information matrix (IM) est. state — replaced by information vector (IV) superior to KF in the following ways data is filtered by summing up the IMs and IVs often numerically more stable Dual character of KF and IF</description></item><item><title>MechanicalState</title><link>https://salehahr.github.io/quartz/studienarbeit/mechanicalstate/</link><pubDate>Sun, 09 Aug 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/mechanicalstate/</guid><description>Source: [SOFA extended documentation](SOFA extended documentation.md) Parents: [Components of the internal model](Components of the internal model.md), [Internal model as a scene graph in SOFA](Internal model as a scene graph in SOFA.md) Backlinks: VecId , [Scene graph in SOFA](Scene graph in SOFA.md), [Mesh topology](Mesh topology.md)
Contains state vectors of each mesh node Coordinates x Velocities v Net force f n nodes: n entries of the state vector Each entry has the same size of the node type (3 for 3D particles) Nodes of different types belong to different MechanicalStates the other MechanicalStates are attached to other scene graph nodes they might be connected with one another using interaction forces</description></item><item><title>(Scaradozzi 2018) SLAM application in surgery</title><link>https://salehahr.github.io/quartz/studienarbeit/scaradozzi-2018-slam-application-in-surgery/</link><pubDate>Thu, 06 Aug 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/scaradozzi-2018-slam-application-in-surgery/</guid><description>Abstract:
SLAM&amp;rsquo;s potential in image-guided surgery assuming static environment Review of main techniques in general robotics SLAM Insight into visual SLAM SLAM in surgery Chapters What is SLAM? Filter-based vs optimisation-based SLAM General Kalman Filter General EKF Unscented Kalman Filter Information Filter &amp;hellip;.
Takeaway
EKF is popular in surgery SLAM techniques Deformable environment encumbers precise registration and data fusion</description></item><item><title>Lamarca 2020 DefSLAM</title><link>https://salehahr.github.io/quartz/studienarbeit/lamarca-2020-defslam/</link><pubDate>Thu, 06 Aug 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/lamarca-2020-defslam/</guid><description>URL: http://arxiv.org/abs/1908.08918 Authors: Lamarca et al Code: http://github.com/UZ-SLAMLab/DefSLAM Results (video): http://www.youtube.com/watch?v=6mmhD2_t6Gs Summary
First monocular SLAM for deformable environments in real-time Most other SLAM implementations assume rigidity Main techniques used (techniques for monocular non-rigid scenes): isometric shape from template (SfT) non-rigid structure from motion (NRSfM) Main principle: computation in two parallel threads (s. DefSLAM framework) Deformation tracking [front end] Deformation mapping [back end] The map from the mapping thread defines the shape-at-rest template used by deformation tracking Validation: compare with ORBSLAM (rigid) Assumes isometric deformation Future work: relocalisation (s.</description></item><item><title>Back-end optimisation</title><link>https://salehahr.github.io/quartz/studienarbeit/back-end-optimisation/</link><pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/back-end-optimisation/</guid><description>Parent: Visual SLAM Implementation Framework Source: cometlabs (Camera pose optimisation)
To compensate for drift of pose estimation Traditionally using EKF ( filter-based ) simple implementation therefore good for small scale estimations Alternative: bundle adjustment (graph optimisation) joint optimisation of the camera pose and the 3D structure parameters combines numerical methods and graph theory increasingly favoured over filtering, due to the latter&amp;rsquo;s inherent inconsistency more efficient when combined with sub-mapping</description></item><item><title>Dead-reckoning</title><link>https://salehahr.github.io/quartz/studienarbeit/dead-reckoning/</link><pubDate>Thu, 30 Jul 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/dead-reckoning/</guid><description>Source: https://en.wikipedia.org/wiki/Dead_reckoning Backlinks: [What is SLAM?](What is SLAM_.md)
In navigation, dead reckoning is the process of calculating one&amp;rsquo;s current position by using a previously determined position, by using estimations of speed and course over elapsed time
s. Brian Douglas video on sensor fusion</description></item><item><title>SA TODO</title><link>https://salehahr.github.io/quartz/studienarbeit/sa-todo/</link><pubDate>Thu, 30 Jul 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/quartz/studienarbeit/sa-todo/</guid><description>Parent: Scope of Studienarbeit See also: [HiWi to-do](hiwi to-do.md), defslam +-orbslam3-integration Studienarbeit Camera-based localisation
Find a classification of approaches/techniques Briefly describe each See if it applies to the project Look into the most promising approach &amp;ndash; how to implement (DefSLAM) DefSLAM Install DefSLAM library Skim through an existing VI-SLAM (rigid) implementation to see how sensor fusion is done (as an overview for the coming sensor fusion task) VINS-Mono, VIORB paper Prepare dummy data for testing VI-SLAM (eventually VI-DefSLAM) — interpolate data between frames and add noise/bias Go through code Get the executables working VideoCapture OpenCV problem &amp;ndash; reinstall with all FFMMPEG options Figure out g2o Go through the rest of DefSLAM Go through the rest of ORBSLAM3 IMU term in cost function IMU preintegration IMU initialisation implement imu term in optimisation (either using ekf (s.</description></item></channel></rss>