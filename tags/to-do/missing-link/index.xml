<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>to-do/missing-link on Zettelkasten</title><link>https://salehahr.github.io/zettelkasten/tags/to-do/missing-link/</link><description>Recent content in to-do/missing-link on Zettelkasten</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><atom:link href="https://salehahr.github.io/zettelkasten/tags/to-do/missing-link/index.xml" rel="self" type="application/rss+xml"/><item><title>Surface alignment in DefSLAM</title><link>https://salehahr.github.io/zettelkasten/studienarbeit/surface-alignment-in-defslam/</link><pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/studienarbeit/surface-alignment-in-defslam/</guid><description>Parent: Mapping step-by-step in DefSLAM Source: lamarca-2020 Goal: to scale the up-to-scale surface (output of NRSfM ) to the proper dimensions get an idea of the proper dimensions from the already estimated map i.e. resulting surface must match the scale of the template $\mathcal{T}_{k-1}$ $\mathcal{T}{k-1}$: deformed map generated by the tracker at the instance of KF $=k$ insertion, with shape-at-rest of $\mathcal{S}{k-1}$ generated from KF: $(k-1)$ result: scale-corrected shape-at-rest $\mathcal{S}_k$ Method: alignment of the map points using Sim(3)</description></item><item><title>Mapping step-by-step in DefSLAM</title><link>https://salehahr.github.io/zettelkasten/studienarbeit/mapping-step-by-step-in-defslam/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/studienarbeit/mapping-step-by-step-in-defslam/</guid><description>Source: lamarca-2020 Parent: DefSLAM framework Steps Recover warps between k and k* (s. [Non-Rigid Guided Matching (b/w KFs) in DefSLAM](non-rigid guided-matching-(b_w-kfs)-in-defslam.md)) with k: anchor keyframes, i.e. KFs where one of the observed map points was initialised with k*: set of best covisible keyframes warps: transformation between the images Ik to Ik* In DefSLAM, Schwarps (a family of warps using 2D Schwarzian equation regularisers) is used Schwarps has something to do with the infinitesimal planarity assumption of NRSfM [ NRSfM ] Process k* to get estimate of an up-to-scale surface  Input of NRSfM: warps [ Surface alignment ] Up-to-scale surface (\hat{S}_k) is aligned with the whole map in order to obtained the scaled surface Sk w.</description></item><item><title>NRSfM in DefSLAM</title><link>https://salehahr.github.io/zettelkasten/studienarbeit/nrsfm-in-defslam/</link><pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/studienarbeit/nrsfm-in-defslam/</guid><description>Parent: Mapping step-by-step in DefSLAM Source: lamarca-2020 See also: NRSfM Assumptions Isometric deformation Infinitesimal planarity [DEF]: any surface can be approximated as a plane at infinitesimal level, all the while maintaining its curvature at a global level Locality The method used here is a local method &amp;ndash;&amp;gt; implies that it handles missing data and occlusions inherently
surface deformation is modelled locally for each point, under the above assumptions Embedding, $\phi_k$ of the scene surface is a parametrisation — transforms an image point to a point on a 3D surface uses the normalised coordinates of the image Ik (xhat, yhat) Procedure A point is matched in more than two keyframes (warps are used in the matching process )</description></item><item><title>50.2.10.1 Discrete Bayesian Filter Predict Step</title><link>https://salehahr.github.io/zettelkasten/studienarbeit/50.2.10.1-discrete-bayesian-filter-predict-step/</link><pubDate>Mon, 31 Aug 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/studienarbeit/50.2.10.1-discrete-bayesian-filter-predict-step/</guid><description>Parent: Discrete Bayesian filter Source: rlabbe Kalman/Bayesian filters in Python The predict step uses the total probability theorem.
Computes total probability of multiple possible events Uses the system model (propagates the states from prev. time step [posterior] to the next one); prediction Accounts for the uncertainty (kernel) in the prediction: produces a prior Generalise the uncertainty using a kernel (distributes the uncertainty over a range around the prediction) Integrate the kernel into the calculations by using convolution * Convolving the &amp;ldquo;current probabilistic estimate&amp;rdquo; with the &amp;ldquo;probabilistic estimate of how much we think the position has changed&amp;rdquo; (from system model) The prior is a &amp;lsquo;degraded&amp;rsquo; version of the belief i.</description></item><item><title>MechanicalState</title><link>https://salehahr.github.io/zettelkasten/studienarbeit/mechanicalstate/</link><pubDate>Sun, 09 Aug 2020 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/studienarbeit/mechanicalstate/</guid><description>Source: [SOFA extended documentation](SOFA extended documentation.md) Parents: [Components of the internal model](Components of the internal model.md), [Internal model as a scene graph in SOFA](Internal model as a scene graph in SOFA.md) Backlinks: VecId , [Scene graph in SOFA](Scene graph in SOFA.md), [Mesh topology](Mesh topology.md)
Contains state vectors of each mesh node Coordinates x Velocities v Net force f n nodes: n entries of the state vector Each entry has the same size of the node type (3 for 3D particles) Nodes of different types belong to different MechanicalStates the other MechanicalStates are attached to other scene graph nodes they might be connected with one another using interaction forces</description></item></channel></rss>