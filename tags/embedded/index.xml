<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>embedded on Zettelkasten</title><link>https://salehahr.github.io/zettelkasten/tags/embedded/</link><description>Recent content in embedded on Zettelkasten</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><lastBuildDate>Sat, 01 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://salehahr.github.io/zettelkasten/tags/embedded/index.xml" rel="self" type="application/rss+xml"/><item><title>branch-instructions</title><link>https://salehahr.github.io/zettelkasten/embedded/branch-instructions/</link><pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/branch-instructions/</guid><description>Source: samek-embedded Branch instructions B.N (Branch) instruction modifies the PC register so that it skips to a different instruction BLT.N conditional branching only modifies PC if the N bit in the APSR is set. the instruction to jump to is encoded within the instruction itself: 0xFC = -4, so jump back 4 instructions, from 0x8e to 0x8a Branching results in pipeline delays &amp;ndash;&amp;gt; solution e.g. loop unrolling BL (branch and link) BL saves the address of the next instruction into the LR link register .</description></item><item><title>interrupts</title><link>https://salehahr.github.io/zettelkasten/embedded/interrupts/</link><pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/interrupts/</guid><description>Source: samek-embedded Allows processor to abruptly change flow of control Upon interrupting: A hardware in the processor changes the value of the PC (program counter) register The interrupt service routine (ISR) is executed After the ISR ends, the processor resumes execution of the original code</description></item><item><title>stack</title><link>https://salehahr.github.io/zettelkasten/embedded/stack/</link><pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/stack/</guid><description>Source: samek-embedded Stack Area of RAM that can grow or shrink from one end. Analogous to a stack of dishes: new data/dishes can only be added to the top, and data/dishes can only be taken away from the top. In ARM , the stack grows towards the lower addresses. Pointed to by the stack pointer . Initial values of the stack are random, therefore it is important, in function calls, to initialise variables correctly.</description></item><item><title>clock gating</title><link>https://salehahr.github.io/zettelkasten/embedded/clock-gating/</link><pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/clock-gating/</guid><description>Source: samek-embedded Clock gating Blocks the clock signal to certain parts of the chip Saves power</description></item><item><title>led-example</title><link>https://salehahr.github.io/zettelkasten/embedded/led-example/</link><pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/led-example/</guid><description>Source: samek-embedded TM4C123G LED Example LED connection The LEDs are connected to the GPIO port F pins of the microcontroller. To use the LEDs, the values of the GPIO port F need to be set &amp;ndash;&amp;gt; address of GPIO PF needed. Bit-wise setting of the LED pins LED Pin number Binary Hex Red 1 0010 0x2 Blue 2 0100 0x4 Green 3 1000 0x8 All 1, 2, 3 1110 0xE Using bit shift operations , the first, second and third bits can be defined as</description></item><item><title>preprocessor-macros</title><link>https://salehahr.github.io/zettelkasten/embedded/preprocessor-macros/</link><pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/preprocessor-macros/</guid><description>Source: samek-embedded Manual definition of macros 1 2 3 4 5 6 7 8 9 10 11 12 #define RCGCGPIO *((unsigned int *)0x400FE608U) #define GPIOF_BASE 0x40025000u #define GPIOF_DIR (*((unsigned int *)( GPIOF_BASE + 0x400U))) #define GPIOF_DEN (*((unsigned int *)( GPIOF_BASE + 0x51CU))) int main() { RCGCGPIO |= 0x20U; GPIODIR |= 0xEU; GPIOF_DEN |= 0xEU; ... } Notes:
Macros can also be partial statements Calculations within the macros don&amp;rsquo;t lead to runtime overheads Header files 1 2 3 4 5 6 #include &amp;lt;stdint.</description></item><item><title>embedded</title><link>https://salehahr.github.io/zettelkasten/embedded/__index/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/__index/</guid><description>Math Bits and bytes Bin-hex-dec table Bit logic Integer overflow Basics Microcontroller Instructions Registers and memory RISC and CISC architectures Clock gating Interrupts Programming General considerations for non-linear control flow Preprocessor macros Stack Variables Local vs.</description></item><item><title>ese-101</title><link>https://salehahr.github.io/zettelkasten/bibliography/ese-101/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/bibliography/ese-101/</guid><description>Embedded Software Engineering 101 by embedded.fm Microcontroller basics</description></item><item><title>instructions</title><link>https://salehahr.github.io/zettelkasten/embedded/instructions/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/instructions/</guid><description> Instructions are e.g. commands such as STORE, ADD, SUBTRACT, branch instructions . The instructions are stored in memory addresses. The values stored at the corresponding addresses encode the instruction to be carried out.</description></item><item><title>integer-overflow</title><link>https://salehahr.github.io/zettelkasten/embedded/integer-overflow/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/integer-overflow/</guid><description>Source: samek-embedded 8-bit representation Hex Dec Bin Hex Dec Bin 0xFF -1 1111 1111 0x01 1 0000 0001 0xFE -2 1111 1110 0x02 2 0000 0010 0xFD -3 1111 1101 0x03 3 0000 0011 &amp;hellip; 0x81 -127 1000 0001 0x7F 127 0111 1111 0x80 -128 1000 0000 Getting the negative hex representation:</description></item><item><title>local-vs-nonlocal-variables</title><link>https://salehahr.github.io/zettelkasten/embedded/local-vs-nonlocal-variables/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/local-vs-nonlocal-variables/</guid><description>Source: samek-embedded Local variables are stored in the register , while non-local variables can be found in memory .
Local variable 1 2 3 4 5 int main() { int counter = 0; ... } Note:
All local variables on the stack go out of scope (get located outside of stack when the stack shrinks) when the function returns, so they can&amp;rsquo;t be accessed. Therefore, it is a bad idea to return a local variable.</description></item><item><title>microcontroller</title><link>https://salehahr.github.io/zettelkasten/embedded/microcontroller/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/microcontroller/</guid><description>Source: ese-101 Constituents of a microcontroller Instructions Registers Memory</description></item><item><title>nonlinear-control-flow</title><link>https://salehahr.github.io/zettelkasten/embedded/nonlinear-control-flow/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/nonlinear-control-flow/</guid><description>Source: samek-embedded General considerations for non-linear control flow Mostly relevant for time-critical code, such as interrupt processing Loop unrolling can be performed to reduce the nonlinearity of the control flow and thus reduce loop overhead Loop overhead Additional instructions (comparisons, branching) The jumps/branching introduces execution delaysx The instruction pipeline Each row is an instruction In the pipeline, the processor works on multiple instructions at a given clock cycle &amp;ndash;&amp;gt; increased throughput In case of branching, already partially executed instructions need to be discarded e.</description></item><item><title>program-with-loop</title><link>https://salehahr.github.io/zettelkasten/embedded/program-with-loop/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/program-with-loop/</guid><description>Source: samek-embedded See also: General considerations for non-linear control flow Code and instructions Code 1 2 3 4 5 6 7 8 9 10 int main() { int counter = 0; while (counter &amp;lt; 10) { ++counter; } return 0; } Disassembly Comparison Original structure Optimised structure In the compiled code, the execution of the while loop is different than that given by the code.</description></item><item><title>registers-memory</title><link>https://salehahr.github.io/zettelkasten/embedded/registers-memory/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/registers-memory/</guid><description>See also: Local vs non-local variables Register Memory Contains [local] data currently being processed Contains program instructions and data that the whole program requires for execution (data that must survive function calls) Small amount of data Larger amount of data Memory locations that are directly accessible by CPU RAM (primary memory, internal to CPU) and hard drive (secondary memory, external to CPU) Faster access by CPU (one CPU clock cycle) Slower access by CPU Source: samek-embedded Registers Some special registers are described in the following.</description></item><item><title>risc-cisc</title><link>https://salehahr.github.io/zettelkasten/embedded/risc-cisc/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/risc-cisc/</guid><description>Source: samek-embedded Computer architectures or more specifically: instruction set architectures (ISA)
Reduced Instruction Set Computer (RISC) architecture Memory can only be read and stored by using special load/store instructions (LDR.N, STR.N) All data manipulations occur in the registers e.g. ARM Complex Instruction Set Computer (RISC) architecture Operands of the current instruction may be stored in memory e.g. x86</description></item><item><title>samek-embedded</title><link>https://salehahr.github.io/zettelkasten/bibliography/samek-embedded/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/bibliography/samek-embedded/</guid><description>Modern Embedded Systems Programming Course by Miro Samek
Math Bit logic Integer overflow Basics Registers and memory RISC and CISC architectures Clock gating Interrupts Programming General considerations for non-linear control flow Preprocessor macros Variables Local vs. non-local variables Pointers Arrays in C Volatile Sample programs Using TM4C123G.</description></item><item><title>simple-program</title><link>https://salehahr.github.io/zettelkasten/embedded/simple-program/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/simple-program/</guid><description>Source: samek-embedded 1 2 3 4 5 6 int main() { int counter = 0; ++counter; ++counter; return 0; } Machine code Instructions Code Instruction Description int counter = 0 MOVS R0, #0 Move value 0 to register R0 ++counter; ADDS R0, R0, #1 Add value 1 to register R0, store it in R0 Registers and memory Register Memory</description></item></channel></rss>