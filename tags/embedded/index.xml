<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>embedded on Zettelkasten</title><link>https://salehahr.github.io/zettelkasten/tags/embedded/</link><description>Recent content in embedded on Zettelkasten</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><lastBuildDate>Fri, 31 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://salehahr.github.io/zettelkasten/tags/embedded/index.xml" rel="self" type="application/rss+xml"/><item><title>clock gating</title><link>https://salehahr.github.io/zettelkasten/embedded/clock-gating/</link><pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/clock-gating/</guid><description>Source: samek-embedded Clock gating Blocks the clock signal to certain parts of the chip Saves power</description></item><item><title>led-example</title><link>https://salehahr.github.io/zettelkasten/embedded/led-example/</link><pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/led-example/</guid><description>Source: samek-embedded TM4C123G LED Example LED connection The LEDs are connected to the GPIO port F pins of the microcontroller. To use the LEDs, the value of the GPIO port F need to be set &amp;ndash;&amp;gt; address of GPIO PF needed. Memory map Initially, this address range contains no data due to clock gating . RCGCGPIO (Register for Clock Gating Control of GPIO) must be set to enabled for the GPIO module to be activated The GPIO module gets a clock signal Access to the GPIO module registers are allowed From the datasheet: Note that each GPIO module clock must be enabled before the registers can be programmed.</description></item><item><title>preprocessor-macros</title><link>https://salehahr.github.io/zettelkasten/embedded/preprocessor-macros/</link><pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/preprocessor-macros/</guid><description>Source: samek-embedded Manual definition of macros 1 2 3 4 5 6 7 8 9 10 11 12 #define RCGCGPIO *((unsigned int *)0x400FE608U) #define GPIOF_BASE 0x40025000u #define GPIOF_DIR (*((unsigned int *)( GPIOF_BASE + 0x400U))) #define GPIOF_DEN (*((unsigned int *)( GPIOF_BASE + 0x51CU))) int main() { RCGCGPIO |= 0x20U; GPIODIR |= 0xEU; GPIOF_DEN |= 0xEU; ... } Notes:
Macros can also be partial statements Calculations within the macros don&amp;rsquo;t lead to runtime overheads Header files 1 2 3 4 5 6 #include &amp;lt;stdint.</description></item><item><title>embedded</title><link>https://salehahr.github.io/zettelkasten/embedded/__index/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/__index/</guid><description>Math Bits and bytes Bin-hex-dec table Bit logic Integer overflow Basics Microcontroller Instructions Registers and memory RISC and CISC architectures Clock gating Programming General considerations for non-linear control flow Preprocessor macros Variables Local vs. non-local variables Pointers Volatile variables Sample programs Using TM4C123G.
Simple (linear) program Program with loop LED example Resources Miro Samek - Modern Embedded Systems Programming Course embedded.</description></item><item><title>ese-101</title><link>https://salehahr.github.io/zettelkasten/bibliography/ese-101/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/bibliography/ese-101/</guid><description>Embedded Software Engineering 101 by embedded.fm Microcontroller basics</description></item><item><title>instructions</title><link>https://salehahr.github.io/zettelkasten/embedded/instructions/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/instructions/</guid><description> Instructions are e.g. commands such as STORE, ADD, SUBTRACT. The instructions are stored in memory addresses. The values stored at the corresponding addresses encode the instruction to be carried out</description></item><item><title>integer-overflow</title><link>https://salehahr.github.io/zettelkasten/embedded/integer-overflow/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/integer-overflow/</guid><description>Source: samek-embedded 8-bit representation Hex Dec Bin Hex Dec Bin 0xFF -1 1111 1111 0x01 1 0000 0001 0xFE -2 1111 1110 0x02 2 0000 0010 0xFD -3 1111 1101 0x03 3 0000 0011 &amp;hellip; 0x81 -127 1000 0001 0x7F 127 0111 1111 0x80 -128 1000 0000 Getting the negative hex representation:</description></item><item><title>local-vs-nonlocal-variables</title><link>https://salehahr.github.io/zettelkasten/embedded/local-vs-nonlocal-variables/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/local-vs-nonlocal-variables/</guid><description>Source: samek-embedded Local variables are stored in the register , while non-local variables can be found in memory .
Example Local variable 1 2 3 4 5 int main() { int counter = 0; ... } Non-local variable 1 2 3 4 5 int counter = 0; int main() { ... } Instruction set Local Non-local More instructions as the CPU needs to load data from memory (in RISC architectures) Loading from memory LDR.</description></item><item><title>microcontroller</title><link>https://salehahr.github.io/zettelkasten/embedded/microcontroller/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/microcontroller/</guid><description>Source: ese-101 Constituents of a microcontroller Instructions Registers Memory</description></item><item><title>nonlinear-control-flow</title><link>https://salehahr.github.io/zettelkasten/embedded/nonlinear-control-flow/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/nonlinear-control-flow/</guid><description>Source: samek-embedded General considerations for non-linear control flow Mostly relevant for time-critical code, such as interrupt processing Loop unrolling can be performed to reduce the nonlinearity of the control flow and thus reduce loop overhead Loop overhead Additional instructions (comparisons, branching) The jumps/branching introduces execution delaysx The instruction pipeline Each row is an instruction In the pipeline, the processor works on multiple instructions at a given clock cycle &amp;ndash;&amp;gt; increased throughput In case of branching, already partially executed instructions need to be discarded e.</description></item><item><title>program-with-loop</title><link>https://salehahr.github.io/zettelkasten/embedded/program-with-loop/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/program-with-loop/</guid><description>Source: samek-embedded See also: General considerations for non-linear control flow Code and instructions Code 1 2 3 4 5 6 7 8 9 10 int main() { int counter = 0; while (counter &amp;lt; 10) { ++counter; } return 0; } Disassembly Comparison Original structure Optimised structure In the compiled code, the execution of the while loop is different than that given by the code.</description></item><item><title>registers-memory</title><link>https://salehahr.github.io/zettelkasten/embedded/registers-memory/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/registers-memory/</guid><description>See also: Local vs non-local variables Register Memory Contains data currently being processed Contains program instructions and data that the program requires for execution Small amount of data Larger amount of data Memory locations that are directly accessible by CPU RAM (primary memory, internal to CPU) and hard drive (secondary memory, external to CPU) Faster access by CPU (one CPU clock cycle) Slower access by CPU Source: samek-embedded Special registers The PC (Program Counter) register holds the memory address of the current instruction to be executed.</description></item><item><title>risc-cisc</title><link>https://salehahr.github.io/zettelkasten/embedded/risc-cisc/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/risc-cisc/</guid><description>Source: samek-embedded Computer architectures or more specifically: instruction set architectures (ISA)
Reduced Instruction Set Computer (RISC) architecture Memory can only be read and stored by using special load/store instructions (LDR.N, STR.N) All data manipulations occur in the registers e.g. ARM Complex Instruction Set Computer (RISC) architecture Operands of the current instruction may be stored in memory e.g. x86</description></item><item><title>samek-embedded</title><link>https://salehahr.github.io/zettelkasten/bibliography/samek-embedded/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/bibliography/samek-embedded/</guid><description>Modern Embedded Systems Programming Course by Miro Samek
Math Bit logic Integer overflow Basics Registers and memory RISC and CISC architectures Clock gating Programming General considerations for non-linear control flow Local vs. non-local variables Pointers Preprocessor macros Volatile Sample programs Using TM4C123G.
Simple (linear) program Program with loop LED example</description></item><item><title>simple-program</title><link>https://salehahr.github.io/zettelkasten/embedded/simple-program/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://salehahr.github.io/zettelkasten/embedded/simple-program/</guid><description>Source: samek-embedded 1 2 3 4 5 6 int main() { int counter = 0; ++counter; ++counter; return 0; } Machine code Instructions Code Instruction Description int counter = 0 MOVS R0, #0 Move value 0 to register R0 ++counter; ADDS R0, R0, #1 Add value 1 to register R0, store it in R0 Registers and memory Register Memory</description></item></channel></rss>